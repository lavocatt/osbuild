#!/usr/bin/python3
"""
Source for downloading files from URLs.

The files are indexed by their content hash. Can download files
that require secrets. The only secret provider currently supported
is `org.osbuild.rhsm` for downloading Red Hat content that requires
a subscriptions.

Internally use curl to download the files; the files are cached in
an internal cache. Multiple parallel connections are used to speed
up the download.
"""


import concurrent.futures
import itertools
import os
import subprocess
import sys
import tempfile

from osbuild.util.checksum import verify_file
from osbuild.util.rhsm import Subscriptions
from osbuild.sources import SourceService, SourceError, SourceErrorKind


SCHEMA = """
"additionalProperties": false,
"definitions": {
  "item": {
    "description": "The files to fetch indexed their content checksum",
    "type": "object",
    "additionalProperties": false,
    "patternProperties": {
      "(md5|sha1|sha256|sha384|sha512):[0-9a-f]{32,128}": {
        "oneOf": [
          {
            "type": "string",
            "description": "URL to download the file from."
          },
          {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL to download the file from."
              },
              "secrets": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "name"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the secrets provider."
                  }
                }
              }
            }
          }
        ]
      }
    }
  }
},
"properties": {
  "items": {"$ref": "#/definitions/item"},
  "urls": {"$ref": "#/definitions/item"}
},
"oneOf": [{
  "required": ["items"]
}, {
  "required": ["urls"]
}]
"""


CURL_CODE_MAP = {
    # networking errors
    5: ("Couldn't resolve proxy", SourceErrorKind.CURL_NETWORKING),
    6: ("Couldn't resolve host", SourceErrorKind.CURL_NETWORKING),
    7: ("Failed to connect to host", SourceErrorKind.CURL_NETWORKING),
    8: ("Unknown FTP server response", SourceErrorKind.CURL_NETWORKING),
    10: ("FTP accept failed", SourceErrorKind.CURL_NETWORKING),
    11: ("FTP weird PASS reply", SourceErrorKind.CURL_NETWORKING),
    12: ("FTP Timeout", SourceErrorKind.CURL_NETWORKING),
    13: ("Unknown response to FTP PASV command", SourceErrorKind.CURL_NETWORKING),
    14: ("Unknown FTP 227 format", SourceErrorKind.CURL_NETWORKING),
    15: ("FTP cannot get host", SourceErrorKind.CURL_NETWORKING),
    16: ("HTTP/2 error", SourceErrorKind.CURL_NETWORKING),
    17: ("FTP could not set binary", SourceErrorKind.CURL_NETWORKING),
    18: ("Partial file. Only a part of the file was transferred", SourceErrorKind.CURL_NETWORKING),
    19: ("FTP could not download/access the given file", SourceErrorKind.CURL_NETWORKING),
    22: ("HTTP page not retrieved", SourceErrorKind.CURL_NETWORKING),
    25: ("Upload failed", SourceErrorKind.CURL_NETWORKING),
    26: ("Read error", SourceErrorKind.CURL_NETWORKING),
    28: ("Operation timeout", SourceErrorKind.CURL_NETWORKING),
    30: ("FTP PORT failed", SourceErrorKind.CURL_NETWORKING),
    31: ("FTP could not use REST", SourceErrorKind.CURL_NETWORKING),
    33: ("HTTP range error", SourceErrorKind.CURL_NETWORKING),
    34: ("HTTP post error", SourceErrorKind.CURL_NETWORKING),
    36: ("Bad download resume", SourceErrorKind.CURL_NETWORKING),
    42: ("Aborted by callback. An application told libcurl to abort the operation",
         SourceErrorKind.CURL_INTERNAL_ERROR),
    43: ("Bad function argument. A function was called with a bad parameter", SourceErrorKind.CURL_INTERNAL_ERROR),
    45: ("Interface error. A specified outgoing network interface could not be used", SourceErrorKind.CURL_NETWORKING),
    47: ("Too many redirects. When following HTTP redirects, libcurl hit the maximum number set",
         SourceErrorKind.CURL_NETWORKING),
    52: ("The server did not reply anything", SourceErrorKind.CURL_NETWORKING),
    55: ("Failed sending network data", SourceErrorKind.CURL_NETWORKING),
    56: ("Failure in receiving network data", SourceErrorKind.CURL_NETWORKING),
    60: ("Unrecognized transfer encoding", SourceErrorKind.CURL_NETWORKING),
    85: ("RTSP: mismatch of CSeq numbers", SourceErrorKind.CURL_NETWORKING),
    86: ("RTSP: mismatch of Session Identifiers", SourceErrorKind.CURL_NETWORKING),
    89: ("No connection available, the session will be queued", SourceErrorKind.CURL_NETWORKING),
    92: ("Stream error in HTTP/2 framing layer", SourceErrorKind.CURL_NETWORKING),
    96: ("QUIC connection error", SourceErrorKind.CURL_NETWORKING),
    # User input errors
    1: ("Unsupported protocol", SourceErrorKind.CURL_BAD_INPUT),
    3: ("URL malformed", SourceErrorKind.CURL_BAD_INPUT),
    21: ("Quote error", SourceErrorKind.CURL_BAD_INPUT),
    48: ("Unknown option specified to libcurl", SourceErrorKind.CURL_BAD_INPUT),
    49: ("Malformed telnet option", SourceErrorKind.CURL_BAD_INPUT),
    67: ("File not found on TFTP server", SourceErrorKind.CURL_BAD_INPUT),
    77: ("The resource referenced in the URL does not exist", SourceErrorKind.CURL_BAD_INPUT),
    # Storage errors
    23: ("Write error. Curl could not write data to a local filesystem or similar",
         SourceErrorKind.CURL_STORAGE),
    37: ("Couldn't read the given file when using the FILE:// ", SourceErrorKind.CURL_STORAGE),
    69: ("Out of disk space on TFTP server", SourceErrorKind.CURL_STORAGE),
    # credentials errors
    9: ("FTP access denied", SourceErrorKind.CURL_CREDENTIALS),
    66: ("The user name, password, or similar was not accepted and curl failed to log in",
         SourceErrorKind.CURL_CREDENTIALS),
    68: ("Permission problem on TFTP server", SourceErrorKind.CURL_CREDENTIALS),
    94: ("Authentication error", SourceErrorKind.CURL_CREDENTIALS),
    # Security errors
    35: ("A TLS/SSL connect error", SourceErrorKind.CURL_SECURITY),
    51: ("The server's SSL/TLS certificate or SSH fingerprint failed verification", SourceErrorKind.CURL_SECURITY),
    53: ("SSL crypto engine not found", SourceErrorKind.CURL_SECURITY),
    54: ("Cannot set SSL crypto engine as default", SourceErrorKind.CURL_SECURITY),
    58: ("Couldn't use the specified SSL cipher", SourceErrorKind.CURL_SECURITY),
    59: ("Peer certificate cannot be authenticated with known CA certificates", SourceErrorKind.CURL_SECURITY),
    63: ("Requested FTP SSL level failed", SourceErrorKind.CURL_SECURITY),
    65: ("Failed to initialize SSL Engine", SourceErrorKind.CURL_SECURITY),
    76: ("Problem with reading the SSL CA cert", SourceErrorKind.CURL_SECURITY),
    79: ("Failed to shut down the SSL connection", SourceErrorKind.CURL_SECURITY),
    82: ("Could not load CRL file, missing or wrong format", SourceErrorKind.CURL_SECURITY),
    83: ("TLS certificate issuer check failed", SourceErrorKind.CURL_SECURITY),
    84: ("The FTP PRET command failed", SourceErrorKind.CURL_SECURITY),
    90: ("SSL public key does not matched pinned public key", SourceErrorKind.CURL_SECURITY),
    91: ("Invalid SSL certificate status", SourceErrorKind.CURL_SECURITY),
    # Internal errors
    2: ("Failed to initialize", SourceErrorKind.CURL_INTERNAL_ERROR),
    4: ("A feature or option that was needed to perform the desired request", SourceErrorKind.CURL_INTERNAL_ERROR),
    27: ("Out of memory. A memory allocation request failed", SourceErrorKind.CURL_INTERNAL_ERROR),
    38: ("LDAP cannot bind", SourceErrorKind.CURL_INTERNAL_ERROR),
    39: ("LDAP search failed", SourceErrorKind.CURL_INTERNAL_ERROR),
    61: ("Invalid LDAP URL", SourceErrorKind.CURL_INTERNAL_ERROR),
    62: ("Maximum file size exceeded", SourceErrorKind.CURL_INTERNAL_ERROR),
    64: ("Sending the data requires a rewind that failed", SourceErrorKind.CURL_INTERNAL_ERROR),
    70: ("Illegal TFTP operation", SourceErrorKind.CURL_INTERNAL_ERROR),
    71: ("Unknown TFTP transfer ID", SourceErrorKind.CURL_INTERNAL_ERROR),
    72: ("File already exists (TFTP)", SourceErrorKind.CURL_INTERNAL_ERROR),
    73: ("No such user (TFTP)", SourceErrorKind.CURL_INTERNAL_ERROR),
    74: ("Character conversion failed", SourceErrorKind.CURL_INTERNAL_ERROR),
    75: ("Character conversion functions required", SourceErrorKind.CURL_INTERNAL_ERROR),
    78: ("An unspecified error occurred during the SSH session", SourceErrorKind.CURL_INTERNAL_ERROR),
    87: ("Unable to parse FTP file list", SourceErrorKind.CURL_INTERNAL_ERROR),
    88: ("FTP chunk callback reported error", SourceErrorKind.CURL_INTERNAL_ERROR),
    93: ("An API function was called from inside a callback", SourceErrorKind.CURL_INTERNAL_ERROR),
    95: ("HTTP/3 layer error", SourceErrorKind.CURL_INTERNAL_ERROR)
}


def fetch(url, checksum, directory):
    secrets = url.get("secrets")
    url_path = url.get("url")
    # Download to a temporary directory until we have verified the checksum. Use a
    # subdirectory, so we avoid copying across block devices.
    with tempfile.TemporaryDirectory(prefix="osbuild-unverified-file-", dir=directory) as tmpdir:
        # some mirrors are sometimes broken. retry manually, because we could be
        # redirected to a different, working, one on retry.
        return_code = 0
        for _ in range(10):
            curl_command = [
                "curl",
                "--silent",
                "--speed-limit", "1000",
                "--connect-timeout", "30",
                "--fail",
                "--location",
                "--output", checksum,
            ]
            if secrets:
                if secrets.get('ssl_ca_cert'):
                    curl_command.extend(["--cacert", secrets.get('ssl_ca_cert')])
                if secrets.get('ssl_client_cert'):
                    curl_command.extend(["--cert", secrets.get('ssl_client_cert')])
                if secrets.get('ssl_client_key'):
                    curl_command.extend(["--key", secrets.get('ssl_client_key')])
            # url must follow options
            curl_command.append(url_path)

            curl = subprocess.run(curl_command, encoding="utf-8", cwd=tmpdir, check=False)
            return_code = curl.returncode
            if return_code == 0:
                break
        else:
            err = CURL_CODE_MAP.get(return_code, [SourceErrorKind.UNKNOWN.name, SourceErrorKind.UNKNOWN])
            raise SourceError(kind=err[1], message=err[0], source=str(url_path))

        if not verify_file(f"{tmpdir}/{checksum}", checksum):
            raise SourceError(kind=SourceErrorKind.CHECKSUM, message=SourceErrorKind.CHECKSUM.name, source=url_path)

        # The checksum has been verified, move the file into place. In case
        # we race another download of the same file, we simply ignore the
        # error as their contents are guaranteed to be  the same.
        try:
            os.rename(f"{tmpdir}/{checksum}", f"{directory}/{checksum}")
        except FileExistsError:
            pass


def download(items, cache, errors_callback):
    # Use threads and not processes to parallelize the workers. The reason being that the type SourceError can't be
    # serialized in between processes and thus raising this exception in the sub process makes it crash.
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        requested_urls = []
        requested_checksums = []
        subscriptions = None

        for (checksum, url) in items.items():

            # Invariant: all files in @directory must be named after their (verified) checksum.
            # Check this before secrets so that if everything is pre-downloaded we don't need secrets
            if os.path.isfile(f"{cache}/{checksum}"):
                continue

            if not isinstance(url, dict):
                url = {"url": url}

            # check if url needs rhsm secrets
            if url.get("secrets", {}).get("name") == "org.osbuild.rhsm":
                # rhsm secrets only need to be retrieved once and can then be reused
                if subscriptions is None:
                    subscriptions = Subscriptions.from_host_system()
                url["secrets"] = subscriptions.get_secrets(url.get("url"))

            requested_urls.append(url)
            requested_checksums.append(checksum)

        results = executor.map(fetch, requested_urls, requested_checksums, itertools.repeat(cache))

        try:
            for _ in results:
                pass
        except SourceError as e:
            errors_callback(e)


class CurlSource(SourceService):

    def download(self, items, cache, _options):
        cache = os.path.join(cache, "org.osbuild.files")
        os.makedirs(cache, exist_ok=True)

        download(items, cache, self.signal_error)


def main():
    service = CurlSource.from_args(sys.argv[1:])
    service.main()


if __name__ == '__main__':
    main()
