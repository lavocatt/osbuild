#!/usr/bin/python3
"""
Source for downloading files from URLs.

The files are indexed by their content hash. Can download files
that require secrets. The only secret provider currently supported
is `org.osbuild.rhsm` for downloading Red Hat content that requires
a subscriptions.

Internally use curl to download the files; the files are cached in
an internal cache. Multiple parallel connections are used to speed
up the download.
"""


import os
import subprocess
import sys

from osbuild.util.checksum import verify_file
from osbuild.util.rhsm import Subscriptions
from osbuild.sources import SourceService, SourceError, SourceErrorKind


SCHEMA = """
"additionalProperties": false,
"definitions": {
  "item": {
    "description": "The files to fetch indexed their content checksum",
    "type": "object",
    "additionalProperties": false,
    "patternProperties": {
      "(md5|sha1|sha256|sha384|sha512):[0-9a-f]{32,128}": {
        "oneOf": [
          {
            "type": "string",
            "description": "URL to download the file from."
          },
          {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL to download the file from."
              },
              "secrets": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "name"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the secrets provider."
                  }
                }
              }
            }
          }
        ]
      }
    }
  }
},
"properties": {
  "items": {"$ref": "#/definitions/item"},
  "urls": {"$ref": "#/definitions/item"}
},
"oneOf": [{
  "required": ["items"]
}, {
  "required": ["urls"]
}]
"""


CURL_CODE_MAP = {
    # networking errors
    5: ("Couldn't resolve proxy", SourceErrorKind.DOWNLOAD),
    6: ("Couldn't resolve host", SourceErrorKind.DOWNLOAD),
    7: ("Failed to connect to host", SourceErrorKind.DOWNLOAD),
    8: ("Unknown FTP server response", SourceErrorKind.DOWNLOAD),
    10: ("FTP accept failed", SourceErrorKind.DOWNLOAD),
    11: ("FTP weird PASS reply", SourceErrorKind.DOWNLOAD),
    12: ("FTP Timeout", SourceErrorKind.DOWNLOAD),
    13: ("Unknown response to FTP PASV command", SourceErrorKind.DOWNLOAD),
    14: ("Unknown FTP 227 format", SourceErrorKind.DOWNLOAD),
    15: ("FTP cannot get host", SourceErrorKind.DOWNLOAD),
    16: ("HTTP/2 error", SourceErrorKind.DOWNLOAD),
    17: ("FTP could not set binary", SourceErrorKind.DOWNLOAD),
    18: ("Partial file. Only a part of the file was transferred", SourceErrorKind.DOWNLOAD),
    19: ("FTP could not download/access the given file", SourceErrorKind.DOWNLOAD),
    22: ("HTTP page not retrieved", SourceErrorKind.DOWNLOAD),
    25: ("Upload failed", SourceErrorKind.DOWNLOAD),
    26: ("Read error", SourceErrorKind.DOWNLOAD),
    28: ("Operation timeout", SourceErrorKind.DOWNLOAD),
    30: ("FTP PORT failed", SourceErrorKind.DOWNLOAD),
    31: ("FTP could not use REST", SourceErrorKind.DOWNLOAD),
    33: ("HTTP range error", SourceErrorKind.DOWNLOAD),
    34: ("HTTP post error", SourceErrorKind.DOWNLOAD),
    36: ("Bad download resume", SourceErrorKind.DOWNLOAD),
    45: ("A specified outgoing network interface could not be used", SourceErrorKind.DOWNLOAD),
    47: ("Too many redirects.", SourceErrorKind.DOWNLOAD),
    52: ("The server did not reply anything", SourceErrorKind.DOWNLOAD),
    55: ("Failed sending network data", SourceErrorKind.DOWNLOAD),
    56: ("Failure in receiving network data", SourceErrorKind.DOWNLOAD),
    60: ("Unrecognized transfer encoding", SourceErrorKind.DOWNLOAD),
    85: ("RTSP: mismatch of CSeq numbers", SourceErrorKind.DOWNLOAD),
    86: ("RTSP: mismatch of Session Identifiers", SourceErrorKind.DOWNLOAD),
    89: ("No connection available, the session will be queued", SourceErrorKind.DOWNLOAD),
    92: ("Stream error in HTTP/2 framing layer", SourceErrorKind.DOWNLOAD),
    96: ("QUIC connection error", SourceErrorKind.DOWNLOAD),
    # credentials errors
    9: ("FTP access denied", SourceErrorKind.DOWNLOAD),
    66: ("failed to log in", SourceErrorKind.DOWNLOAD),
    68: ("Permission problem on TFTP server", SourceErrorKind.DOWNLOAD),
    94: ("Authentication error", SourceErrorKind.DOWNLOAD),
    # Security errors
    35: ("A TLS/SSL connect error", SourceErrorKind.DOWNLOAD),
    51: ("The server's SSL/TLS certificate or SSH fingerprint failed verification", SourceErrorKind.DOWNLOAD),
    53: ("SSL crypto engine not found", SourceErrorKind.DOWNLOAD),
    54: ("Cannot set SSL crypto engine as default", SourceErrorKind.DOWNLOAD),
    58: ("Couldn't use the specified SSL cipher", SourceErrorKind.DOWNLOAD),
    59: ("Peer certificate cannot be authenticated with known CA certificates", SourceErrorKind.DOWNLOAD),
    63: ("Requested FTP SSL level failed", SourceErrorKind.DOWNLOAD),
    65: ("Failed to initialize SSL Engine", SourceErrorKind.DOWNLOAD),
    76: ("Problem with reading the SSL CA cert", SourceErrorKind.DOWNLOAD),
    79: ("Failed to shut down the SSL connection", SourceErrorKind.DOWNLOAD),
    82: ("Could not load CRL file, missing or wrong format", SourceErrorKind.DOWNLOAD),
    83: ("TLS certificate issuer check failed", SourceErrorKind.DOWNLOAD),
    84: ("The FTP PRET command failed", SourceErrorKind.DOWNLOAD),
    90: ("SSL public key does not matched pinned public key", SourceErrorKind.DOWNLOAD),
    91: ("Invalid SSL certificate status", SourceErrorKind.DOWNLOAD),
    # User input errors
    1: ("Unsupported protocol", SourceErrorKind.BAD_INPUT),
    3: ("URL malformed", SourceErrorKind.BAD_INPUT),
    21: ("Quote error", SourceErrorKind.BAD_INPUT),
    48: ("Unknown option specified to libcurl", SourceErrorKind.BAD_INPUT),
    49: ("Malformed telnet option", SourceErrorKind.BAD_INPUT),
    67: ("File not found on TFTP server", SourceErrorKind.BAD_INPUT),
    77: ("The resource referenced in the URL does not exist", SourceErrorKind.BAD_INPUT),
    # Storage errors
    23: ("Curl could not write data to a local filesystem.", SourceErrorKind.STORAGE),
    37: ("Couldn't read the given file when using the FILE:// ", SourceErrorKind.STORAGE),
    69: ("Out of disk space on TFTP server", SourceErrorKind.STORAGE),
    # Internal errors
    2: ("Failed to initialize", SourceErrorKind.FAILED),
    4: ("A feature or option that was needed to perform the desired request", SourceErrorKind.FAILED),
    27: ("Out of memory. A memory allocation request failed", SourceErrorKind.FAILED),
    38: ("LDAP cannot bind", SourceErrorKind.FAILED),
    39: ("LDAP search failed", SourceErrorKind.FAILED),
    42: ("Aborted by callback. An application told libcurl to abort the operation", SourceErrorKind.FAILED),
    43: ("Bad function argument. A function was called with a bad parameter", SourceErrorKind.FAILED),
    61: ("Invalid LDAP URL", SourceErrorKind.FAILED),
    62: ("Maximum file size exceeded", SourceErrorKind.FAILED),
    64: ("Sending the data requires a rewind that failed", SourceErrorKind.FAILED),
    70: ("Illegal TFTP operation", SourceErrorKind.FAILED),
    71: ("Unknown TFTP transfer ID", SourceErrorKind.FAILED),
    72: ("File already exists (TFTP)", SourceErrorKind.FAILED),
    73: ("No such user (TFTP)", SourceErrorKind.FAILED),
    74: ("Character conversion failed", SourceErrorKind.FAILED),
    75: ("Character conversion functions required", SourceErrorKind.FAILED),
    78: ("An unspecified error occurred during the SSH session", SourceErrorKind.FAILED),
    87: ("Unable to parse FTP file list", SourceErrorKind.FAILED),
    88: ("FTP chunk callback reported error", SourceErrorKind.FAILED),
    93: ("An API function was called from inside a callback", SourceErrorKind.FAILED),
    95: ("HTTP/3 layer error", SourceErrorKind.FAILED)
}


class CurlSource(SourceService):

    content_type = "org.osbuild.files"
    max_workers = 4

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.subscriptions = None

    def transform(self, checksum, desc):
        url = desc
        if not isinstance(url, dict):
            url = {"url": url}

        # check if url needs rhsm secrets
        if url.get("secrets", {}).get("name") == "org.osbuild.rhsm":
            # rhsm secrets only need to be retrieved once and can then be reused
            if self.subscriptions is None:
                self.subscriptions = Subscriptions.from_host_system()
            url["secrets"] = self.subscriptions.get_secrets(url.get("url"))
        return checksum, url

    def fetch_one(self, checksum, desc):
        secrets = desc.get("secrets")
        url = desc.get("url")
        # Download to a temporary sub cache until we have verified the checksum. Use a subdirectory, so we avoid copying
        # across block devices. some mirrors are sometimes broken. retry manually, because we could be redirected to a
        # different, working, one on retry.
        return_code = 0
        for _ in range(10):
            curl_command = [
                "curl",
                "--silent",
                "--speed-limit", "1000",
                "--connect-timeout", "30",
                "--fail",
                "--location",
                "--output", checksum,
            ]
            if secrets:
                if secrets.get('ssl_ca_cert'):
                    curl_command.extend(["--cacert", secrets.get('ssl_ca_cert')])
                if secrets.get('ssl_client_cert'):
                    curl_command.extend(["--cert", secrets.get('ssl_client_cert')])
                if secrets.get('ssl_client_key'):
                    curl_command.extend(["--key", secrets.get('ssl_client_key')])
            # url must follow options
            curl_command.append(url)

            return_code = subprocess.run(curl_command, encoding="utf-8", cwd=self.tmpdir, check=False).returncode
            if return_code == 0:
                break
        else:
            message, kind = CURL_CODE_MAP.get(return_code, [SourceErrorKind.FAILED.name, SourceErrorKind.FAILED])
            return self.signal_error(SourceError(kind=kind,
                                                 message=message,
                                                 source=str(url)))

        if not verify_file(f"{self.tmpdir}/{checksum}", checksum):
            return self.signal_error(SourceError(kind=SourceErrorKind.CHECKSUM,
                                                 message=SourceErrorKind.CHECKSUM.name,
                                                 source=str(url)))

        # The checksum has been verified, move the file into place. In case we race another download of the same file,
        # we simply ignore the error as their contents are guaranteed to be  the same.
        try:
            os.rename(f"{self.tmpdir}/{checksum}", f"{self.cache}/{checksum}")
        except FileExistsError:
            pass


def main():
    service = CurlSource.from_args(sys.argv[1:])
    service.main()


if __name__ == '__main__':
    main()
